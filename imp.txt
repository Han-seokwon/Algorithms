import sys
import collections as col    
    
def shortest_path(board, knight_pos, goal_pos):  # bfs
    # 시작점에서 멀어질 때마다 카운트를 하나씩 증가시킴
    # knight_pos = (x,y)
    # goal_pos = (x,y)
    queue = col.deque([(knight_pos[0] , knight_pos[1] )])

    # knight가 이동할 수 있는 조합
    x_point = [1, 1, -1, -1, 2, 2, -2, -2]
    y_point = [2, -2, 2, -2, 1, -1, 1, -1,]

    while len(queue) != 0:
        unit = queue.popleft()
        x = unit[0]  # x축
        y = unit[1]  # y축
        if x == goal_pos[0] and y == goal_pos[1]: # 종점에 도착한 경우
            return board[x][y] # 그 때의 카운트를 반환

        cnt = board[x][y]  # 현재 좌표의 카운트

        for p in range(8):
            if 0 <= x + x_point[p] <= board_length-1 and 0 <= y + y_point[p] <= board_length-1:
                if board[x + x_point[p]][y + y_point[p]] == 0: # 방문한 적 없는 위치
                    queue.append(( x + x_point[p],y + y_point[p]))
                    board[x + x_point[p]][y + y_point[p]] = cnt + 1  # 현재 좌표의 카운트에서 +1을 대입

# 입력
# for i in range(int(sys.stdin.readline())):
for i in range(1):
    board_length = int(sys.stdin.readline())
    board = [[0]*board_length for i in range(board_length)]
    knight_pos = tuple(map(int, sys.stdin.readline().split()))
    goal_pos = tuple(map(int, sys.stdin.readline().split()))
    print(shortest_path(board, knight_pos, goal_pos))

for i in board:
    print(i)

    
    
    
    
